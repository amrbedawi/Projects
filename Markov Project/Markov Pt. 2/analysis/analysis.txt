This is the analysis for Markov Part 2, Fall 2018

Amr Bedawi
aab73 

Answer the questions from the assignment 
that are reproduced below

(1) Determine (from running Benchmark.java) how long it takes for 
BaseMarkov to generate 2,000, 4,000, 8,000, 16,000, and 32,000 
random characters using the default file and an order 5 Markov Model. 
Include these timings in your report. 
The program also generates 4,096 characters using texts that increase in 
size from 496,768 characters to 4,967,680 characters (10 times the number).  
Do the timings support the O(NT) analysis for BaseMarkov?

time	source	#chars
0.245	496768	2000
0.414	496768	4000
0.850	496768	8000
1.418	496768	16000
3.923	496768	32000

0.443	496768	4096
0.868	993536	4096
1.297	1490304	4096
1.770	1987072	4096
2.178	2483840	4096
2.902	2980608	4096
3.248	3477376	4096
3.434	3974144	4096
4.128	4470912	4096
4.425	4967680	4096

- These timings support the O(NT) analysis. In the first set of times, the amount of characters in the text(N) remains constant, while the amount of random characters generated by .getFollows(T) doubles each time. We see that each time T doubles, the amount of time it takes to run the .getRandomText doubles as well (roughly). This is what we would expect to see for code with complexity O(NT). This holds true in the second set as well where N changes and T is constant. When N changes by a certain proportion, the time it takes for .getRandomText to run changes by the same proportion. For example, when N roughly doubles from 496768 to 993536, the time roughly doubles from 0.433 seconds to 0.868 seconds. When N increases by roughly 50% from 993536 characters to 1490304 characters, the time roughly increases by 50% from .868 seconds to 1.297 seconds. This is what we would expect from code with complexity O(NT). 
 
(2) Determine (from running Benchmark.java) how long it takes for 
EfficientMarkov to generate 2,000, 4,000, 8,000, 16,000, and 32,000 
random characters using the default file and an order 5 Markov Model. 
Include these timings in your report. 
The program also generates 4,096 characters using texts that increase in 
size from 496,768 characters to 4,967,680 characters (10 times the number).  
Do the timings support the O(N+T) analysis for EfficientMarkov?

time	source	#chars
0.169	496768	2000
0.158	496768	4000
0.116	496768	8000
0.112	496768	16000
0.100	496768	32000

0.154	496768	4096
0.198	993536	4096
0.351	1490304	4096
0.483	1987072	4096
0.541	2483840	4096
0.715	2980608	4096
1.144	3477376	4096
1.896	3974144	4096
2.013	4470912	4096
2.445	4967680	4096

- Yes, the timings support the O(N + T) analysis of the code. Looking at the first set of timings, the difference in time for T = 2000 and T = 32000 is negligible. Each time the amount of characters increase, runtime changes slightly. I would have expected runtime to increase slightly, but in the first set of timings, it decreases. Looking at the second set of timings gives us a better understanding of the Big O analysis of EfficientMarkov. Each time N increases, so does runtime; however, the increase is not large for a single incrementation of N. For example, the runtime difference for N = 496768 and N = 993536 is just 0.041 seconds. This is what we would expect from code with a runtime of O(N + T). If N increased slightly while T is held constant, then we should only see a small increase in the runtime of the code. 

(3)The tests in the class Benchmark use an order-5 Markov Model. 
Run tests that you think are appropriate to determine if the order of the 
Markov Model has a significant impact on the running time for BaseMarkov. 
Explain your reasoning.

- The order of the Markov has an effect on the runtime of BaseMarkov when the order is significantly larger than 5. When I ran benchmark with and order of 50 and of 500, the runtimes remained relatively the same but were slightly shorter. When I ran it with an order of 4000, the times were significantly shorter for practically every amount of characters. When I increased the order to 5000, the code did not function properly and terminated.An increase in order means that getFollows is called less, so when the order is significantly large, getFollows is not called as many times. This causes the code to run faster. The runtimes for an order of 4000 were as follows: 

time	source	#chars
0.000	496768	2000
0.000	496768	4000
0.795	496768	8000
1.183	496768	16000
2.787	496768	32000

0.009	496768	4096
0.020	993536	4096
0.030	1490304	4096
0.039	1987072	4096
0.050	2483840	4096
0.059	2980608	4096
0.069	3477376	4096
0.082	3974144	4096
0.095	4470912	4096
0.106	4967680	4096